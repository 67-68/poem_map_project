这个名为 `poem_map` 的 Godot 4.5 项目，是一个以唐代（公元618年-907年）为背景的动态交互式历史、地理与诗词可视化系统。其核心目标是通过时间流逝、地理空间映射、势力划分以及人际交互，来呈现诗人在特定历史节点创作诗词的背景与轨迹。

项目的架构设计采用了独立游戏开发中极具效率的**“2D逻辑驱动 + Shader渲染辅助”**模式，整体结构高度解耦，数据流向清晰。以下是事无巨细的功能与架构总结：

### 一、 核心架构设计

项目采用了重度依赖全局单例（Autoload）的事件驱动（Event-Driven）和数据驱动（Data-Driven）架构，以建立一个稳定且简洁的底层框架。

* **启动与生命周期管理：** * `Gameboot` 作为第一顺位的单例，严格把控其他核心服务（如全局状态、导航系统）的初始化顺序，避免依赖冲突。
* **全局状态中心 (`Global.gd`)：** * 扮演了全局数据仓库和事件总线的双重角色。它管理着地图边界、时间跨度（618-907年）、当前时间节点、天气与情绪（如 `sad_color`）、以及所有核心的数据字典（诗人数据 `poet_data`、诗词数据 `poem_data`、势力范围 `factions`、州府 `base_province` 等）。
* 在初始化阶段，系统会通过 `DataLoader` 从 JSON 和 CSV 文件中读取结构化数据，并转换为运行时字典，实现逻辑与数据的完全分离。


* **事件总线 (`EventBus.gd`)：** * 集中存放跨模块的底层信号（如玩家点击地图事件 `user_click_map`），实现模块间解耦。

### 二、 核心功能模块

#### 1. 时间轴模拟系统 (`time_service.gd`)

这是整个世界运转的“心脏”。

* 时间以“年”为单位流逝，从 618 年流向 907 年。
* 支持播放、暂停以及时间跳转 (`jump_to`)，并且会实时广播当前时间进度（`ratio_time`），驱动地图上的人物移动、势力变迁和诗词创作事件。

#### 2. 地理与势力渲染系统 (`world/map.gd`)

采用 Shader 实现了高效的“伪3D”级别的交互与区域渲染。

* **像素级精确拾取：** 没有使用繁琐的 2D 碰撞体，而是通过一张纯色的索引图（`PROVINCE_INDEX_MAP_PATH`），在玩家点击屏幕时，将鼠标坐标转化为 UV 坐标，再通过采集图片像素颜色，映射到对应的州府实体，精准且性能极高。
* **势力地盘动态渲染：** 势力范围（Faction）并非静态图片，系统会在内存中实时构建“州府 -> 势力”的映射表，并生成一张包含势力颜色的查找表（LUT Texture）。随后通过 Shader 将其注入到地图材质中，实现了版图的动态变色和划分。

#### 3. 动态轨迹与信使系统

为了表现人员流动（如皇帝的圣旨、地方的税收或诗人的贬谪），项目构建了一套复杂的路径生成与动画系统。

* **路径生成器 (`path_visualizer.gd`)：** 利用 `NavigationService` 计算出两个州府之间的最短路径节点，然后生成一条贝塞尔曲线（`Curve2D`）。为了让路径看起来更自然（不像机械直线），在生成时引入了随机的坐标扰动噪音 (`PATH_NOISE`)。
* **信使实体 (`messager.gd` & `messager_manager.gd`)：** 信使会在预设的路径上利用 `PathFollow2D` 进行匀速移动 (`speed_px_per_sec`)。
* 视觉表现极佳：过去走过的路线由 CPU 维护轨迹线 (`TrailLine`)，而未来的路线则通过修改 Shader 的 `progress_ratio` 参数动态展示。
* 信使被分为不同类型：如“圣旨”（金色、速度极快）、“粮税”（小麦色、速度较慢）以及普通“消息”，并会在移动中动态抛出漂浮文字。



#### 4. 诗词交互与 UI 动画系统 (`poem_popup.gd` & `size_service.gd`)

系统为诗词的弹出设计了一套高度定制的“卷轴展开”动画。

* **动态尺寸计算 (`size_service.gd`)：** 这是一个非常精妙的底层工具。因为 UI 节点（特别是文本）的尺寸需要在渲染后才能确定，该服务可以在动画播放前，预先模拟扩大文本框（关闭折叠、取消裁剪），计算出最终所需的理想尺寸，然后再将其重置。
* **卷轴动画 (`poem_popup.gd`)：** 利用上述计算出的尺寸，通过控制 `custom_minimum_size:x`，使用 `Tween` 动画配合三次曲线 (`TRANS_CUBIC`)，平滑地实现面板横向展开、文本浮现、稀有度印章盖下的连贯视觉表现。
* **全服播报：** 诗词弹出后，会在全局触发消息通知：“某诗人在某年创作了某诗，稀有度为何”。

#### 5. 调试与控制台 (`controller.gd`)

* 为了方便测试，项目中内置了一个类似开发者控制台的 `LineEdit` 组件。通过输入特定格式的命令（如 `$信号名 参数` 或 `函数名 参数`），可以直接在运行时触发全局事件或调用全局方法，极大地提高了开发和测试的效率。

6. P社级中央时间调度器 (Centralized Timeline Dispatcher)为了应对唐代近 300 年跨度内海量的历史事件（诗人出生、诗词创作、政权更迭等），系统彻底摒弃了极其消耗性能且容易导致死循环的“实体自轮询（_process）”模式，转而采用类似 Paradox 历史策略游戏的脉冲与优先队列架构。
双轨队列设计 (Master-Slave Timeline)：Master 史书数据库： 在初始化阶段（DataLoader），将剧本中的静态历史事件全部转化为 absolute_float_time (年份 + 月份偏移)，并装入只读的 Master 数组。
Active 消费队列： 运行时实际轮询的优先队列 ($O(1)$ 复杂度)。只有时间到达队首元素的触发阈值时，才会 pop_front() 并执行回调。
时空穿梭支持 (Time Scrubbing)： 当玩家拖动进度条进行时间倒流（jump_to）时，系统会清空当前 Active 队列，并基于新的时间点从 Master 数据库中重新抄录和排序未来事件。
⚠️ 架构限制与妥协 (Limitations)：状态副作用不可逆： 队列重建仅能恢复“未来将要触发的事件”，但无法自动撤销已经发生的事件对世界造成的视觉或状态改变（例如：地图因安史之乱变红）。在执行时光倒流时，必须辅以全局的世界状态重置函数。
浮点精度陷阱： 极近的时间节点（如同一天发生的两件事）在转换为 float 后可能存在极微小的精度误差，需确保同一时间戳的事件执行顺序不具有严格互斥性。

7. 纯对象 UI 缓冲池 (Decoupled Manual UI Buffer)在历史的高光时刻（如某一年内多位诗人同时创作了名篇），时间总线会在同一帧内并发抛出多个事件。为了防止 UI 弹窗在屏幕上发生“宇宙大爆炸”式的重叠，系统引入了极轻量的 RefCounted 缓冲池机制。
生产者-消费者解耦： TimeService 作为生产者，只负责无脑将数据 push 进缓冲池；缓冲池自动接管控制权，触发全局时停（TimeService.pause()）。
玩家输入驱动： 摒弃了基于动画结束的自动轮播。队列的推进（pop_and_next）严格绑定于玩家对当前弹窗的“关闭/选择”操作。点一下，出一个，直到队列清空，时间流逝方才恢复。
零肉体开销： 缓冲池本身不继承任何 Node，作为一个纯粹的内存对象（RefCounted）存在于管理器中。没有需要轮询的节点，用完即被 GC（垃圾回收）无情销毁，保证了场景树的绝对纯洁。
⚠️ 架构限制与用途 (Limitations & Use Cases)：强阻塞性： 一旦有事件入池，整个世界的时钟将被强行冻结。此机制仅适用于重大叙事或必须玩家确认的剧本节点。
非适用场景： 对于非关键性的动态信息（如信使路过某地的区域播报），应绕过此缓冲池，直接使用地图上的漂浮文字（Toast）渲染，以保证大地图的沉浸感和流动性。

### 总结

整体而言，该系统采用了一个极其成熟的游戏化框架来承载文化与历史科普的目的。通过**数据驱动初始化 -> 时间轴推进 -> 事件触发 -> 空间路径演算 -> Shader 视觉反馈 -> 动态 UI 呈现**这一套标准化的流程（SOP），成功地将唐代的地理空间变迁与诗人的人际、创作历程进行了有机的结合。

